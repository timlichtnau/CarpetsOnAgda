{-# OPTIONS --cubical --without-K #-}
open import CarpetCubical3 
open import PointedTypesCubical
open import Relation.Binary.Bundles 
open import Agda.Builtin.Sigma
open import Data.Product
open import PropositionReasoning
open import Level
--open import Relation.Binary.PropositionalEquality hiding (trans)
-- open import Relation.Binary.Core
open import Function.Base using (_âˆ˜_)
open import Relation.Binary.Definitions
open import Relation.Binary.Structures using (IsPartialOrder)
open import Equalizer
open import SemiLattices
open import cubical-prelude hiding (_âˆ¨_ ; _âˆ§_)
open import cubicalEqualityReasoning
open import HomoAlgStd
open import PropositionReasoning
import Relation.Binary.Reasoning.Preorder


module _ (C : Carpet {o} {â„“} {e}) where
  open Carpet C 
  open SemiLattice J
  open Funs J
  open CarpetHelper C
  private variable
    i j k l : Carrier
  fibre-map : {x y : ElUnder l} {f : l â‰¤ k} â†’ (projâ‚‚ (push x)) â‰£[ Ï• f ] (projâ‚‚ (push y)) â†’  elem x â‰¡[ k ] elem y  
  fibre-map {x = x} {y = y} {f = f} aha = record {
    left = inScope x â–  f ;
    right = inScope y â–  f ;
    eq =
      elem x Â§ (inScope x â–  f)
        â‰¡Ë˜âŸ¨ actrans (inScope x) f âŸ©
      push x Â§ f
        â‰¡âŸ¨ toElâ‰¡ (toFib (Ï• f) aha) âŸ©
      push y Â§ f
        â‰¡âŸ¨ actrans (inScope y) f âŸ©
      elem y Â§ (inScope y â–  f) âˆ } where open Reasoning
  postulate FIBRE-IND :  {x y : ElUnder l} {f : l â‰¤ k} â†’ isEquiv (fibre-map {x = x} {y = y} {f = f})
  fibre-inv : {x y : ElUnder l} {f : l â‰¤ k} â†’ elem x â‰¡[ k ] elem y â†’ (projâ‚‚ (push x)) â‰£[ Ï• f ] (projâ‚‚ (push y))
  fibre-inv p = projâ‚ (projâ‚ (equiv-proof FIBRE-IND p))
  toIm : (f : k â‰¤ l) â†’ [ x âˆ¶ X k ]â‡’ âŸ¨ im (Ï• f) âŸ© (âŸ¦ Ï• f âŸ§ x)
  toIm f y =  âˆ£  y , refl âˆ£â‚‹â‚ 
  pushâ†’Im' : (x : X k) â†’ (f : k â‰¤ l) â†’ ã€ im (Ï• f) ã€‘
  pushâ†’Im' x f = (âŸ¦ Ï• f âŸ§ x) ,  toIm f x 
  pushâ†’Im : (x : ElUnder k) â†’ (f : k â‰¤ l) â†’ ã€ im (Ï• f) ã€‘
  pushâ†’Im x f = pushâ†’Im' (projâ‚‚ (push x )) f 

  module _ {p : j â‰¤ k} {q : k â‰¤ l} where
    private
      f = Ï• p
      g = Ï• q
      h = Ï• (p â–  q)
    EpiIntro : ker g âŠ‚ im f â†’ im g âŠ‚ im h â†’ surj f
    EpiIntro info1 info2 x =
      (a , aIsInPreImageofImX) â† info2 & imx ,
      la ( âŸ¦ f âŸ§ a , (toIm p a , func1 a aIsInPreImageofImX)) 
       where --a aIsInPreImageofImX
        open Monad truncMonad
        imx = (pushâ†’Im' x q)
        func1 : (a : X j) â†’ (âŸ¦ h âŸ§ a â‰¡ projâ‚ imx ) â†’ (âŸ¦ f âŸ§ a) â‰£[ g ] x --
        func1 a ee =  begin
          âŸ¦ f âŸ§ a
            âˆ¼âŸ¨ fibre-inv (bwd (toElâ‰¡ ee) (deeper (left-Eat q) (fwd reflâ‰¡) ) ) âŸ©
          snd (push ((k , x) , reflexivity))
            âˆ¼âŸ¨  inh' g (reflex x) âŸ©
          x âˆ  where open Relation.Binary.Reasoning.Preorder (â„™ g)
        la : Î£ (X k) (Î» y â†’ asType (âŸ¨ im f âŸ© y)  Ã— y â‰£[ g ] (x)) â‡’ âŸ¨ im f âŸ© x
        la (.(pt (ğ• k)) , (_ , kern zz)) = info1 & (_ ,  sym zz)
        la (y , (p , inh)) = p
    surjComp : surj f â†’ surj g â†’ surj h
    surjComp info1 info2 x =
      (a , aP) â† info2 x ,
      (b , bP) â† info1 a ,
      return (b , (sym (transit' p q _) âˆ™ cong âŸ¦ g âŸ§ bP âˆ™ aP)) where open Monad truncMonad
    surjComp' : surj f â†’ surj h â†’ surj g
    surjComp' info1 info2 x =
      (a , aP) â† info2 x ,
      return (âŸ¦ f âŸ§ a , transit' p q _ âˆ™ aP)   where open Monad truncMonad
   
