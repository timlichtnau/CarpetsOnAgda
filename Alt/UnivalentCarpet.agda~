{-# OPTIONS --cubical #-}
open import CarpetCubical3
open import PointedTypesCubical
open import Relation.Binary.Bundles 
open import Agda.Builtin.Sigma
open import Data.Product
open import Agda.Builtin.Unit
open import PropositionReasoning
open import Level
--open import Relation.Binary.PropositionalEquality hiding (trans)

open import Function.Base using (_âˆ˜_)
open import Relation.Binary.Definitions 
open import Relation.Binary.Structures using (IsPartialOrder ; IsPreorder)
open import Equalizer
open import SemiLattices
open import cubical-prelude hiding (_âˆ¨_ ; _âˆ§_)
open import cubicalEqualityReasoning
open import HomoAlgStd
open import PropositionReasoning
import Relation.Binary.Reasoning.Preorder

module UnivalentCarpet (carpet : Carpet {o} {â„“} {e} ) where
open Carpet carpet
open SemiLattice J
open CarpetHelper carpet

open Funs J
open import Relation.Binary renaming (_â‡’_ to _==>_)
open import DoublePreorderReasoning
open import FibreArgumentation
private variable
  j k l : Carrier
record SubEl : Type (suc zero âŠ” o) where
  constructor _,_
  field
    daIn : Carrier 
    sub : (SubPtd (ð• daIn))
open SubEl public
open Monad (truncMonad)
{--
_â†’[_]_ : (A B : SubEl) â†’ (l : Carrier ) â†’ Type (o âŠ” e)
_â†’[_]_ (j , A) l (k , B)  =
  (x : ã€ A ã€‘) â†’ âˆ¥ (Î£[ y âˆˆ ã€ B ã€‘ ] ((j , projâ‚ x) â‰¡[ l ] (k , projâ‚ y) )) âˆ¥â‚‹â‚ 
--}
record _=>_ (A B : SubEl) : Type (o âŠ” e) where
  constructor Co
  field
    uncert : Carrier
    atLeast : daIn A âˆ¨ daIn B â‰¤ uncert
    provider : (x : ã€ sub A ã€‘) â†’  âˆ¥ (Î£[ y âˆˆ ã€ sub B ã€‘ ] ((daIn A , projâ‚ x) â‰¡[ uncert ] (daIn B , projâ‚ y) )) âˆ¥â‚‹â‚
  
open _=>_ public
refl=> : {A : SubEl} â†’ A => A
refl=> {A = (i , A)} = Co i  (sup reflexivity reflexivity)  (Î» x â†’  âˆ£ x , reflâ‰¡  âˆ£â‚‹â‚)
trans=> : Transitive _=>_ -- {A B C : SubEl} â†’ TransitivA => B â†’ B => C â†’ A => C
trans=> (Co l h p) (Co l' h' q)= Co (l âˆ¨ l') (resp (uB â–  h) (uB' â–  h') )  Î» x â†’
  (y , Î±) â† p x ,
  (z , Î²) â† q y ,
  return (z , transâ‰¡ Î± Î²)  
IncUncert : {A B : SubEl} â†’ ((Co j h p) : A => B) â†’ j â‰¤ k  â†’ A => B
IncUncert {k = k}  (Co j h p) q = Co k (h â–  q) Î» x â†’ z â† p x , return ((projâ‚ z , deeper  q (projâ‚‚ z)))
record _âŠ†_ (A B : SubEl) : Type e where
  constructor _,_
  field
    myEdge : daIn A â‰¤ daIn B
    myArg : (x : ã€ sub A ã€‘) â†’ asType (âŸ¨ sub B âŸ© (âŸ¦ Ï• myEdge âŸ§ (projâ‚ x)))
    
-- substAlongReflex : {B : SubPtd (ð• j)}  â†’ ã€ B ã€‘ â†’ 

introâŠ‚ : {A B : SubPtd (ð• j) } â†’ A âŠ‚ B â†’ (j , A) âŠ† (j , B)
introâŠ‚ {B = B} (âŠ‚: p) = reflexivity , (Î» x â†’ subst (Î» r â†’ asType( âŸ¨ B âŸ© r)) (sym (reflex _)) (p x))
outroâŠ‚ : {A B : SubPtd (ð• j)} â†’ (j , A) âŠ† (j , B) â†’ A âŠ‚ B
outroâŠ‚ p = âŠ‚: (Î» x â†’ {!!})
=>ToâŠ‚ : {A B : SubEl} â†’ (p : A => B) â†’ uncert p â‰¤ daIn B â†’ A âŠ† B
=>ToâŠ‚ {A = A} {B = B} p q = ((uB â–  atLeast p) â–  q) , Î» x â†’
  truncIndSyntax (âŸ¨ sub B âŸ© (âŸ¦ Ï• ((uB â–  atLeast p) â–  q) âŸ§ (projâ‚ x)))
  (provider p x)
  Î» bb â†’  subst (Î» z â†’  asType (âŸ¨ sub B âŸ© z)) (sym (foo x (projâ‚ bb) (projâ‚‚ bb))) (projâ‚‚ (projâ‚ bb)  ) where

  foo : (x : ã€ sub A ã€‘)  â†’
    (y :  ã€ sub B ã€‘) â†’
    (daIn A , projâ‚ x) â‰¡[ uncert p ] (daIn B , projâ‚ y)
    â†’  âŸ¦ Ï• ((uB â–  atLeast p) â–  q) âŸ§ (projâ‚ x) â‰¡ projâ‚ (y)
  foo x y pf = {!cong projâ‚ eq!} where open _â‰¡[_]_ pf
âŠ†Rel : PreOrderOn SubEl e
âŠ†Rel = _âŠ†_ , (introâŠ‚ (reflâŠ‚ _)) , (Î» {k = A} (p , Î±) (q , Î²) â†’ p â–  q ,
    Î» x â†’ subst (TâŸ¨ sub A âŸ©) ( (transit' p q (projâ‚ x))) (Î² (_ , Î± x))) -- ( () ) , {--
{--
trans =  } 
--}
=>Rel : PreOrderOn SubEl (o âŠ” e)
=>Rel =  _=>_ , ( refl=> , trans=>  )
imp : _âŠ†_ ==>  _=>_
imp  {x = A} {y = B} (p , Î±) = Co (daIn B) (sup p reflexivity) Î» x â†’
  return ((âŸ¦ Ï• p âŸ§ (projâ‚ x) , Î± x) , fwdEasy p)  

pushForward :  {A : SubEl} â†’ (p : daIn A â‰¤ j) â†’ A  âŠ† (j , im (Ï• p))
pushForward {j = j} {A = A}  p = p , Î» x â†’   âˆ£ projâ‚ x  , refl  âˆ£â‚‹â‚
pushBackward : (p : k â‰¤ j) â†’ (j , im (Ï• p)) => (k , full)
pushBackward {k = k} {j = j}  p = Co j (right-Eat p) Î» (x , q) â†’
  (a , b) â† q ,
  return ((a , *) , symm (bwd (toElâ‰¡ b) reflâ‰¡))

          
module ARG where
   open DoubleReasoning SubEl âŠ†Rel =>Rel (Î» xâ‰¤y y~z â†’ IncUncert (trans=> (imp xâ‰¤y) y~z) (sup (uB â–  atLeast y~z) reflexivity)) public
