open import Data.Product
open import Relation.Binary.PropositionalEquality
open import PointedTypes2

open import Univalence
module FibreInduction where
open  Ptd
open _âŠ™â†’_
open import Basics
open â‰¡-Reasoning
open import Function
hasSection : {X Y : Set} â†’ (f : X â†’ Y) â†’ Set
hasSection {X} {Y} f = Î£[ g âˆˆ (Y â†’ X) ] ((y : Y) â†’ f (g y) â‰¡ y)
fib : {X Y : Set} â†’ (f : X â†’ Y) â†’ Y â†’ Set
fib {X} {Y} f y = Î£[ x âˆˆ X ] (f x â‰¡ y)
$_$ : {X Y : Set} {f : X â†’ Y} â†’ (x : X) â†’ fib f (f x)
$ x $ = (x , refl)

module _ {X : Set} (Y : X â†’ Set) where
  section = (x : X) â†’ Y x
  eva : (x' : X) â†’ section â†’ Y x'
  eva x' f = f x'
  ExtProp = (x : X) â†’ hasSection (eva x)
ExtProp' : {A : Set} â†’ {X : A â†’ Set} â†’ (Y : (a : A) â†’ X a â†’ Set) â†’ (f : (a : A) â†’ X a) â†’ Set
ExtProp' {A} Y f = (a : A) â†’ hasSection (eva (Y a) (f a))  
ext : {X : Set} â†’ {Y : X â†’ Set}  {x' : X} â†’ ExtProp Y â†’ Y x' â†’ section Y
ext {x' = x'} ep = projâ‚ (ep x')
module FibInd {P : Set} {B : Set} {A : Set} (f : P â†’ B) (g : B â†’ A) where
{--  Y : (p : P) â†’ fib g (g (f p)) â†’ Set
  Y p b = fib f (projâ‚ b) --}
  --Y : {p : P} â†’ fib g (g (f p)) â†’ Set
  --Y b = fib f (projâ‚ b)
  Y : {a : A} â†’ fib g a â†’ Set
  Y b = fib f (projâ‚ b)
  SEP : Set
  SEP = section (Î» p â†’ ExtProp (Y {g (f (p))}))
  BASE = Î£[ p âˆˆ P ] fib g (g (f p))

  iso' : {X : Set} {Y : X â†’ Set} {Z : (x : X) â†’ Y x â†’ Set}  â†’ ((x : X) â†’ (y : Y x) â†’ Z x y) â†’ ((x , y) : Î£ X Y) â†’ Z x y
  iso' sep z = sep (projâ‚ z) (projâ‚‚ z)
  YY : (v : Î£ P (Î» vâ‚ â†’ fib g (g (f vâ‚)))) â†’ Set
  YY = Î» v â†’ hasSection (eva Y (projâ‚‚ v))
  pmap : P â†’ BASE
  pmap p =  (p , $ f p $)
  localSectionThroughPoint : B â†’ Set
  localSectionThroughPoint b = hasSection (eva Y $ b $) -- ExtProp' Y (Î» p â†’ $ f p $) 

  can : (p : P) â†’ (section localSectionThroughPoint) â†’ hasSection (eva Y $ f p $)
  can p = eva (localSectionThroughPoint) (f p)

  postulate  FIBRE-IND : ExtProp localSectionThroughPoint
  can' : (p : P) â†’ SEP â†’ localSectionThroughPoint (f p)
  can' p = can p âˆ˜ (Î» sep q â†’ {!iso' sep ?!})
--  can'Inv : (p : P) â†’  localSectionThroughPoint p â†’ SEP
--  can'Inv p lsectionThroughp q b = (Î» fibb â†’ helper {!!}) , Î» yqb â†’ {!!} where
--    helper : fib f (f q) â†’ section Y
--    helper = projâ‚ (ext FIBRE-IND lsectionThroughp q)
module FibInduction {â„™ : Ptd} {ğ”¹ : Ptd} {ğ”¸ : Ptd} (pf : â„™ âŠ™â†’ ğ”¹) (pg : ğ”¹ âŠ™â†’ ğ”¸) where

  private
    f = âŸ¦ pf âŸ§
    g = âŸ¦ pg âŸ§
    A = UâŠ™ ğ”¸
    B = UâŠ™ ğ”¹
    P = UâŠ™ â„™
    Bf : A â†’ Set
    Bf = fib g
  Pf : B â†’ Set
  Pf = fib f  
  localSection : (a : A) â†’ Set
  localSection a = (b : Bf a) â†’ (Pf (projâ‚ b))
  
 
  eval : {a : A} (b : Bf a) â†’ (localSection a) â†’ (fib f (projâ‚ b)) 
  eval b s = s b
  module _ (p : P) where
    ev : localSection (g (f p)) â†’ fib f (f p)
    ev = eval $ f p $    
    localBasedSection : Set
    localBasedSection = fib (projâ‚ âˆ˜ ev) p -- Î£[ s âˆˆ localSection (g (f p)) ] projâ‚ (ev p s) â‰¡ p
  -- Î£[ s âˆˆ localSection (pt ğ”¸) ] projâ‚ (s (pt ğ”¹ , psv pg)) â‰¡ pt â„™


    pointExtendsToASection : Set
    pointExtendsToASection = hasSection ev
  SectionExtensionPrinciple : Set
  SectionExtensionPrinciple = (p : P) â†’ pointExtendsToASection (p) 
  can : SectionExtensionPrinciple â†’ localBasedSection (pt â„™)
  can sep =  ( s ,  aim ) where ----tp {!!} (psv (pg âŠ™âˆ˜ pf))
    sec : hasSection (eval $ (f (pt â„™)) $)
    sec = sep (pt â„™)
    s : localSection (g (f (pt â„™)))
    s = (projâ‚ sec) $ pt â„™ $
    aim : projâ‚ (s $ f (pt â„™) $) â‰¡ pt â„™
    aim = ap (projâ‚) (projâ‚‚ sec $ pt â„™ $)
  postulate fiber-induction : hasSection can
  getSep : localBasedSection (pt â„™) â†’ SectionExtensionPrinciple
  getSep = projâ‚ fiber-induction

Ex : {ğ”¸ ğ”¹ : Ptd} â†’ (g : ğ”¹ âŠ™â†’ ğ”¸) â†’ (f' : UâŠ™ ğ”¹ â†’ Set) â†’ (a : UâŠ™ ğ”¸)
  â†’ ((b : fib âŸ¦ g âŸ§ (pt ğ”¸)) â†’ f' (projâ‚ b))
  â†’ Î£[ b âˆˆ fib âŸ¦ g âŸ§ a ] (f' (projâ‚ b))
  â†’  ((b : fib âŸ¦ g âŸ§ a) â†’ f' (projâ‚ b))
Ex {ğ”¸} {ğ”¹} g f' a ker ((w1 , w2) , w3) b = foo where
  oB = ker (pt ğ”¹ , psv g)
  B = UâŠ™ ğ”¹
  â„™ : Ptd
  â„™ = (Î£ B f' , (pt ğ”¹) , oB)
  pf : â„™ âŠ™â†’ ğ”¹
  pf = projâ‚ , refl
  open FibInduction pf g

  sep : SectionExtensionPrinciple
  sep = getSep ((Î» b â†’ ((projâ‚ b , ker' b)) , refl) , refl) where
      ker' : (b : fib âŸ¦ g âŸ§ (âŸ¦ g âŸ§ (pt ğ”¹) )) â†’ f' (projâ‚ b) 
      ker' b = ker (projâ‚ b , projâ‚‚ b â–  psv g)   
  bar : pointExtendsToASection (w1 , w3)
  bar = sep (w1 , w3)
  bar' : Pf (projâ‚ b)
  bar' = (tp localSection w2 (projâ‚ bar (((w1 , w3)) , refl))) b
  foo : f' (projâ‚ b)
  foo = let ((_ , x) , y) = bar' in  tp f' y x 

module _ {A' : Ptd} {B : UâŠ™ A' â†’ Set} (b* : B (pt A')) (P : Î£ (UâŠ™ A') B â†’ Set) (p* : P (pt A' , b*)) where
  open  Ptd
  private
    A = UâŠ™ A'
    ğ”¹ = Î£ A B
    â„™ = Î£ ğ”¹ P
    -a : â„™ â†’ A
    -a ( (a , _) , _) = a
    -b : â„™ â†’ ğ”¹
    -b = projâ‚
    SectionOver : A â†’ Set
    SectionOver a = (b : B a) â†’ P (a , b)
    stdP : â„™ 
    stdP = ((pt A' , b*) , p*)
    -- â„™' = Î£[ x âˆˆ A ] (Î£[ y âˆˆ B x ] P ( x , y))
    !_! : {a : A} â†’ (b : B a) â†’ SectionOver a â†’  P (a , b) -- (Î£[ y âˆˆ B a ] P ( a , y))
    ! b !  f = f b
    â„™' : A â†’ Set
    â„™' a = Î£[ b âˆˆ B a ] (P ( a , b))
    iso : {a : A} â†’ â„™' a â†’ â„™
    iso {a} (b , p) = ((a , b) , p)
    stdp' : â„™' (pt A')
    stdp' = (b* , p*)
    prB : (p : â„™) â†’ (B (-a p))
    prB p = projâ‚‚ (-b p)
  hasSecProp : Set
  hasSecProp = ((p : â„™) â†’ hasSection ! prB p !)
  can : â„™' (pt A') â†’ hasSecProp â†’ SectionOver (pt A')
  can p f = projâ‚ (f (iso p)) (projâ‚‚ p)
  postulate axiomP : (p : â„™' (pt A')) â†’ hasSection (can p)
  axiom = axiomP stdp'
--  INV : SectionOver (pt A') â†’ (p  : â„™) â†’ P (-b p) â†’ SectionOver (-a p)
 -- INV s p =
  app : {X : Set} {Y : X â†’ Set} {f g : (x : X) â†’ Y x } â†’ f â‰¡ g â†’ (x : X) â†’ f x â‰¡ g x
  app refl x = refl
  SEC : (s : SectionOver (pt A')) â†’ âˆ€ x â†’ (can stdp' ((projâ‚  axiom) s)) x â‰¡ s x -- can ((projâ‚ axiom) s) â‰¡ s
  SEC s x = app (projâ‚‚  axiom s) x -- app (projâ‚‚ axiom s) x
  INV : SectionOver (pt A') â†’ (p : â„™) â†’ SectionOver (-a p)
  INV s p = projâ‚ ((projâ‚ axiom) s p) (projâ‚‚ p)
 -- test : (s : SectionOver (pt A')) â†’ ((b , p) : Î£ (B (pt A')) (Î» b â†’ P ( pt A' , b ))) â†’
 --   INV s ((pt A' , b) , p) b â‰¡ p
 -- test s (b , p) = {!SEC ? ?!}
  --f (projâ‚‚  (-b p)) â‰¡ projâ‚‚ p)

