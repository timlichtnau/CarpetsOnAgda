{-# OPTIONS --cubical #-}
open import Level
open import CubicalBasics.cubical-prelude hiding (_âˆ¨_)
open import Data.Product
open import CubicalBasics.PointedTypesCubical
open import CubicalBasics.PropositionReasoning
open import CubicalBasics.IsomorphismCubical
fib : {A : Set â„“} {B : Set â„“'} â†’ (A â†’ B) â†’ B â†’ Set (â„“ âŠ” â„“')
fib f b = âˆƒ (Î» a â†’ f a â‰¡ b)
fibIsSet : {A : Set â„“} {B : Set â„“'} â†’ isSet A â†’ isSet B â†’  (f : A â†’ B) â†’ (b : B) â†’  isSet (fib f b)
fibIsSet isSetA isSetB f b = Î£set isSetA Î» a â†’ isPropâ†’isSet (isSetB _ _)
open Monad truncMonad
module _ {l}  {ğ”¸ : Ptd {l}} {ğ”¹ : Ptd {l}} (f : ğ”¸ âŠ™â†’ ğ”¹) where

  src = UâŠ™ ğ”¸
  trg = UâŠ™ ğ”¹
  pushforward : SubPtd ğ”¸ â†’ SubPtd ğ”¹
  pushforward A = (Î» x â†’ âˆ¥ Î£[ a âˆˆ ã€ A ã€‘ ] (âŸ¦ f âŸ§ (projâ‚ a) â‰¡ x)âˆ¥) ,  âˆ£ ( (pt ğ”¸ , ptâˆˆ A) , psv f) âˆ£â‚‹â‚
  pullback : SubPtd ğ”¹ â†’ SubPtd ğ”¸
  pullback (B , b) = (Î» x â†’ B ( âŸ¦ f âŸ§ x)) , subst (Î» b â†’ asType (B b)) (sym (psv f)) b
  functPush : {A A' : SubPtd ğ”¸} â†’ A âŠ‚ A' â†’ pushforward A âŠ‚ pushforward A'
  functPush AâŠ‚A' = âŠ‚: Î» x â†’
    (a , pf) â† projâ‚‚ x ,
    return (((projâ‚ a) , (AâŠ‚A' & a)) , pf)
  funcPull :   {A A' : SubPtd ğ”¹} â†’ A' âŠ‚ A â†’ pullback A' âŠ‚ pullback A
  funcPull A'âŠ‚A = âŠ‚: Î» (a , pf) â†’ A'âŠ‚A & ((âŸ¦ f âŸ§ a) , pf)
  im : SubPtd ğ”¹
  im = pushforward full --  (Î» b â†’  âˆ¥ Î£[ a âˆˆ src ] (âŸ¦ f âŸ§ a â‰¡ b) âˆ¥  ) , âˆ£ ( pt ğ”¸ , psv f) âˆ£â‚‹â‚
  pushIntoPshFWD : {A : SubPtd ğ”¸} â†’ ã€ A ã€‘ â†’ ã€ pushforward A ã€‘
  pushIntoPshFWD (x , y) = (âŸ¦ f âŸ§ x) , âˆ£  ((x , y)) , refl âˆ£â‚‹â‚
  pushIntoImg : UâŠ™ ğ”¸ â†’ ã€ im ã€‘ 
  pushIntoImg x = pushIntoPshFWD {A = full} (x , *) -- 
  ker : SubPtd ğ”¸
  ker = pullback (0Sub) -- (Î» x â†’ âŸ¦ f âŸ§ x â‰¡%  UâŠ™' ğ”¹ % pt ğ”¹) , (psv f)

  -- takePreIm : {b : B} {Q : Proposition {â„“}} â†’  asType (âŸ¨ im âŸ© b)   â†’ (( Î£[ a âˆˆ A ] (âŸ¦ f âŸ§ a â‰¡ b) ) â‰¡> Q) â†’ asType Q
  -- takePreIm z g = (z >>> g) --{! (Î» z â†’ (g (fst z))) !}
  surj : Type l
  surj =  full âŠ‚ im  -- [ b âˆ¶ trg ]â‡’ âŸ¨ im âŸ© b ----

  surjP : Proposition
  surjP = forallP (âŸ¨ im âŸ©)
  mono : Type l
  mono = ker âŠ‚ 0Sub
  

module _ {l}  {ğ”¸ : Ptd {l}} {ğ”¹ : Ptd {l}} {â„‚ : Ptd {l}} {f : ğ”¸ âŠ™â†’ ğ”¹} {g : ğ”¹ âŠ™â†’ â„‚} where
  surjComp  :  surj g â†’ surj f â†’ surj (g âŠ™âˆ˜ f)
  surjComp isSurjG isSurjF = âŠ‚: Î» x â†’
    y â† isSurjG &  x ,
    z â† isSurjF & ((projâ‚ (projâ‚ y)) , *) ,
    return ((projâ‚ z) , (cong âŸ¦ g âŸ§ (projâ‚‚ z)  âˆ™ projâ‚‚ y) )
  ezFactor : (A : SubPtd ğ”¸) â†’ pushforward f A âŠ‚ pullback g (pushforward (g âŠ™âˆ˜ f) A)
  ezFactor A = âŠ‚: (Î» x â†’
    (a , pf) â† projâ‚‚ x ,
    return (a , cong âŸ¦ g âŸ§ pf)
    )


