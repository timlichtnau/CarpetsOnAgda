{-# OPTIONS --cubical --without-K #-}
open import Data.Integer.Base renaming (_âŠ”_ to max) renaming (_â‰¤_ to _â‰¤â„¤_ ; neg to negate)
open import Data.Nat.Base using (suc)
open import CubicalBasics.PointedTypesCubical
open import HomoAlgStd
open import CubicalBasics.PointedTypesCubical
import UnivalentCarpet2
open import Data.Product
open import CubicalBasics.cubical-prelude
open import CarpetCubical3
open import Agda.Builtin.Equality renaming (_â‰¡_ to _â‰¡'_)
open import SemiLattices
open import Data.Integer.Properties
open import EqualitiesCubical
open import Level
open import Algebra.Construct.NaturalChoice.Base
open import Axiom.UniquenessOfIdentityProofs
open import Relation.Binary.Definitions

data Dir : Set where
  H : Dir
  V : Dir
  D : Dir
record Pos : Set where
  constructor _!_!_
  field
    dir : Dir
    xarg : â„¤
    yarg : â„¤

open Pos
toxy : Pos â†’ â„¤ Ã— â„¤
toxy (d ! x ! y ) = (x , y)
neg : Dir â†’ Dir
neg H = V
neg V = H
neg D = D
_+x_ : Dir â†’ â„¤ â†’ â„¤
H +x y = + 1 + y
V +x y = y
D +x y = + 1 + y
_+y_ : Dir â†’ â„¤ â†’ â„¤
H +y y = y
V +y y  = + 1 + y
D +y y = + 1 + y
infix 21 _Â°
_Â° : Pos â†’ Pos
p Â° = (dir p) ! (dir p +x xarg p) ! (dir p +y yarg p)
invVec : Pos â†’ Pos
invVec (d ! x ! y) = d ! (- x) ! (- y)
infix 21 _!
_! : Pos â†’ Pos
(v ! x ! y) ! = neg v ! x ! y
infixl 15 _âœ¯_ 
_âœ¯_ : â„¤ â†’ Pos â†’ Pos
(+ 0) âœ¯ j = j
(+ (suc p)) âœ¯ j = (+ p) âœ¯ j Â°
(-[1+ 0 ]) âœ¯ j = invVec j
(-[1+ (suc p) ]) âœ¯ j = ( + p) âœ¯ (invVec j Â° )

module _  where
  _â‰¤_ : â„¤ Ã— â„¤ â†’ â„¤ Ã— â„¤ â†’ Set
  _â‰¤_ = Î» (a , b) (a' , b') â†’ a â‰¤â„¤ a' Ã— b â‰¤â„¤ b'
  -- We want a relative version of grids, i.e. a carpet on J should be the same as the transportet carpet along p on J + p, for this we have to replace the Carrier by â„¤ Ã— â„¤
  --comp to FibreArgumentation
  J : SemiLattice lzero lzero lzero
  J = record
        { Carrier = â„¤ Ã— â„¤
        ; CarIsSet = Î» (a , b) (a' , b') p q i j â†’ ((â„¤isSet (Î» i â†’ projâ‚ (p i)) (Î» i â†’ projâ‚ (q i))) i j) , (((â„¤isSet (Î» i â†’ projâ‚‚ (p i)) (Î» i â†’ projâ‚‚ (q i))) i j)) 
        ; _â‰¤_ = _â‰¤_
        ; â‰¤isProp = Î» (p , p') (q , q') â†’ Î» i â†’ â‰¤isProp p q i , â‰¤isProp p' q' i
        ; reflexivity =  â‰¤-refl , â‰¤-refl
        ; _â– _ = Î» (p , q) (p' , q') â†’ â‰¤-trans p p' , â‰¤-trans q q'
        ; _âˆ¨_ = Î» (a , b) (a' , b') â†’ max a a' , max b b' 
        ; comm = Î» {(a , b)} {(a' , b')} i â†’
          (Builtinâ‰¡ToCubicalâ‰¡ (âŠ”-comm a a') i , Builtinâ‰¡ToCubicalâ‰¡ (âŠ”-comm b b') i )
        ; uB = Î» {(a , b)} {(a' , b')} â†’   iâ‰¤iâŠ”j a a' , iâ‰¤iâŠ”j b b'
        ; sup = Î» {(a , b)} {(a' , b')} {( a'' , b'')} p q â†’ (âŠ”-lub  (projâ‚ p) (projâ‚ q)) , (âŠ”-lub  (projâ‚‚ p) (projâ‚‚ q))
        } where


        â‰¤isProp : {a b : â„¤} â†’ isProp (a â‰¤â„¤ b)
        â‰¤isProp p q = Builtinâ‰¡ToCubicalâ‰¡ (â‰¤-irrelevant p q)
        â‰¡-irrelevant : Irrelevant {A = â„¤} _â‰¡'_
        â‰¡-irrelevant = Decidableâ‡’UIP.â‰¡-irrelevant _â‰Ÿ_
        â„¤isSet : {a b : â„¤} â†’ isProp (a â‰¡ b)
        â„¤isSet {a = a} {b = b} =  substEquiv isProp EqEquiv Î» p q â†’ Builtinâ‰¡ToCubicalâ‰¡ (â‰¡-irrelevant p q)
  grid : Set (lsuc lzero)
  grid = CarpetOnJ J 
-- âŠ”-identityË¡
--  ; âŠ“-identityÊ³  to  âŠ”-identityÊ³
 -- gridInduction : âˆ€ {e} â†’ (A : grid â†’ Pos â†’ Set e) â†’ ((G : grid) â†’ A G (H ! 0 ! 0)) â†’ (G : grid) â†’ (p : Pos) â†’ A G p
 -- gridInduction A indStart G p = {!indStart!}
  module GridHelper (G : grid) where

    C = CarpetOnJToCarpet G
    
    open UnivalentCarpet2 C hiding (_â‰¤_) public
    private
      r : Dir
      r = H
    f' : (p : Pos) â†’ (xarg p , yarg p) â‰¤ (xarg ( p Â°) , yarg (p Â° ))
    f' (H ! x ! y) =  (iâ‰¤suc[i] x , â‰¤-refl)
    f' (V ! x ! y) =  (â‰¤-refl , iâ‰¤suc[i] y)
    f' (D ! x ! y) =  (iâ‰¤suc[i] x , iâ‰¤suc[i] y)
    f : (p : Pos) â†’ ğ• (xarg p , yarg p) âŠ™â†’ ğ• (xarg ( p Â°) , yarg (p Â° ))
    f p = Ï• (f' p)
    module _ (p : Pos) where
      
      fâŸ© : _ â‰¤ _ -- (r +x (r +x i)) (r +y (r +y j))
      fâŸ© = f' (p Â°)
      fâ‡£ :  _ â‰¤ _ -- (r +x (r +x i)) (r +y (r +y j))
      fâ‡£  = f' (p Â° !)
      f| : (c : â„¤) â†’ _ â‰¤ _
      f| c = f' ((c âœ¯ p ! ) !)
    module _ (i k : â„¤) where
     private 
       p = r ! i ! k
       g = fâ‡£ p
       j = f p
       h = f (D ! i ! k)


    exactRow : Pos â†’ Set 
    exactRow p = im (Ï• (f' p)) â†” ker (Ï• (fâŸ© p))
    Exact : (r : Dir) â†’ (l : â„¤) â†’ Set
    Exact H l = {cnter : â„¤} â†’  exactRow (H ! cnter ! l)
    Exact V l = {cnter : â„¤} â†’ exactRow (V ! l ! cnter)
    Exact D l = {cnter : â„¤} â†’ exactRow ((D ! cnter ! l)) -- WEIRD

{--
  triangle : {X Y Z : Ptd} â†’ (f : X âŠ™â†’ Y) â†’ (g : Y âŠ™â†’ Z) â†’ (h : X âŠ™â†’ Z) â†’ (g âŠ™âˆ˜ f) â‰ˆ h â†’ grid
  triangle {X} {Y} {Z} f g h gf~h = (record {
    ğ• = ğ• ;
    mycarp = record { Ï• = {! !} ; reflex = {!!} ; transit = {!!} }
    }) where

    ğ•' : â„¤ â†’ â„¤ â†’ Ptd
    ğ•' zero zero = X
    ğ•' zero (suc zero) = Y
    ğ•' zero (suc (suc x)) = PğŸ
    ğ•' 1 0 = Y
    ğ•' 1 1 = Z
    ğ•' 1 (suc (suc x)) = PğŸ
    ğ•' (suc (suc x)) 0 = PğŸ
    ğ•' (suc (suc x)) (suc y) = PğŸ
    f'' : (p : Pos) â†’ ğ•' (xarg p) (yarg p) âŠ™â†’ ğ•' (xarg (p Â°)) (yarg (p Â°)) -- (r +x i) (r +y j)
    f'' (H ! zero ! zero) =  f
    f'' (V ! zero ! zero) = f
    f'' (D ! zero ! zero) = h
    f'' (H ! 0 ! 1) = g
    f'' (V ! 0 ! 1) =  c1

    f'' (V ! 1 ! 0) = g
    f'' (H ! zero ! suc (suc yargâ‚)) = c1
    f'' (H ! suc xargâ‚ ! zero) = c1
    f'' (H ! suc xargâ‚ ! suc yargâ‚) = c1
    f'' (V ! zero ! suc yargâ‚) = c1
    f'' (V ! suc (suc xargâ‚) ! zero) =  c1
    f'' (V ! suc zero ! suc yargâ‚) = c1
    f'' (V ! suc (suc xargâ‚) ! suc yargâ‚) = c1
    f'' (D ! suc x ! zero) =  c1
    f'' (D ! zero ! suc yargâ‚) = c1
    f'' (D ! suc x ! suc yargâ‚) = c1
    ğ• : â„¤ Ã— â„¤ â†’ Ptd
    ğ• = Î» (i , j) â†’ ğ•' i j --}
  --  Ï• : {i j : (â„¤ Ã— â„¤)} â†’ i â‰¤ j â†’ ğ• i âŠ™â†’ ğ• j
  --  Ï• {i = .â„¤.zero , b} {j = a' , b'} (zâ‰¤n , snd) = {!!}
  --  Ï• {i = .(â„¤.suc _) , b} {j = .(â„¤.suc _) , b'} (sâ‰¤s fst , snd) = {!!}
  {--
    comp' : (i j : â„¤) â†’ f' (H ! i ! (suc j)) âŠ™âˆ˜ f' (V ! i ! j) â‰ˆ f' (D ! i ! j)
    comp' zero zero = gf~h
    comp' zero (suc j) = Î» x â†’ refl 
    comp' (suc i) j = Î» x â†’ refl
  --}


