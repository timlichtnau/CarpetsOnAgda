{-# OPTIONS --cubical --without-K #-}
open import CarpetCubical3
open import CubicalBasics.PointedTypesCubical
open import Relation.Binary.Bundles 
open import Agda.Builtin.Sigma
open import Data.Product
open import Agda.Builtin.Unit
open import CubicalBasics.PropositionReasoning
open import Level
--open import Relation.Binary.PropositionalEquality hiding (trans)

open import Function.Base using (_âˆ˜_)
open import Relation.Binary.Definitions 
open import Relation.Binary.Structures using (IsPartialOrder ; IsPreorder)
open import Equalizer3
open import SemiLattices
open import CubicalBasics.cubical-prelude hiding (_âˆ¨_ ; _âˆ§_)
open import CubicalBasics.cubicalEqualityReasoning
open import HomoAlgStd hiding (fib)

import Relation.Binary.Reasoning.Base.Single
import HomoAlgOnCarpets
import SmartImplication
open import Relation.Binary renaming (_â‡’_ to _==>_)
open import DoublePreorderReasoning
open import FibreArgumentation
import NaiveImplication
module SupporterInduction {o e} (carpet : Carpet {o} {â„“} {e} ) where

open CarpetHelper carpet  
open SmartImplication carpet 

private variable
  j k l : Carrier

open Monad (truncMonad)
private
  open NaiveImplication carpet
  open HomoAlgOnCarpets carpet 
  â‰¡ToFib : {A B : SubPtd (ð• j)} {k : Carrier} {x' : X j} â†’ (x : ã€ A ã€‘) â†’ (ed : j â‰¤ k) â†’ (y : (j , projâ‚ x) â‰¡[ k ] (j , x')) â†’ fib (Ï• ed) (projâ‚ x) x'
  â‰¡ToFib x ed y = fibInverse (Ï• ed) (isEmb (eq' y))


  ind' :  {B B' : SubPtd (ð• j)} {P : SubEl} {k : Carrier} {ed : j â‰¤ k} â†’
    (b=>p : (j , B')  => P)
    (ker=>p : Ker ed => P)
    ((x , xp) : ã€ B ã€‘) â†’
    (Î£[ (y , yp) âˆˆ ã€ B' ã€‘ ] (x â‰£[ Ï• ed ] y)) â†’
    (j , B) ~ (x , xp) ~ uncert (b=>p) âˆ¨ uncert (ker=>p)  ~> P
  ind'  {j = j} {B = A} {B' = B} {P = P } {ed = ed} b=>p ker=>p = ind where
    ind :  ((x , xp) : ã€ A ã€‘) â†’ (Î£[ (y , yp) âˆˆ ã€ B ã€‘ ] (x â‰£[ Ï• ed ] y)) â†’  (j , A) ~ (x , xp) ~ uncert (b=>p) âˆ¨ uncert (ker=>p)  ~> P
    ind (x , xp) ((y , yp) , (kern 0=fx _)) = fmap (Î£map (Î» a â†’ deeper uB')) (provider ker=>p (x , (sym (0=fx))))
    ind (x , xp) ((.x , yp) , inh) = fmap (Î£map (Î» a â†’ deeper uB)) (provider (b=>p) (x , yp))  

record SupScheme (B B' : SubPtd (ð• j)) {q : j â‰¤ k} (A P : SubEl) : Type (suc zero âŠ” e âŠ” o) where

    field
      A=>B : A =>' (j , B)
      A=>B' : A =>' (j , B')
      edge : UNC A=>B âˆ¨ UNC A=>B' â‰¤ k
      B'=>P : (j , B') =>' P
      Ker=>P : Ker q =>' P --right' (back A=>B) â–  uB {UNC A=>B} {UNC A=>B'}
open SupScheme
SupInd : {B B' : SubPtd (ð• j)} {q : j â‰¤ k} {A P : SubEl} â†’ (S : SupScheme B B' A P) â†’ A =>'[ UNC (A=>B S) âˆ¨ (UNC (B'=>P S) âˆ¨ UNC (Ker=>P S)) ] P
SupInd {q = q} record { A=>B = A=>B ; A=>B' = A=>B' ; B'=>P = B'=>P ; edge = ed' ; Ker=>P = Ker=>P } =
  NOTHING (supInd' (back A=>B) (back A=>B') (back B'=>P) (back ( introâŠ‚ (kerfâŠ‚kergf   ed' q) âˆ· Ker=>P )))   where

    supInd' : {A P : SubEl}   {B B' : SubPtd (ð• j)} â†’ (Ï : A => (j , B)) â†’ (Ï' : A => (j , B')) â†’ (Ïˆ : (j , B') => P) â†’ (Î¶ : Ker ( right' Ï â–  uB {uncert Ï} {uncert Ï'}  ) => P) â†’  A => P
    supInd' {j = j} {A = A} {P = P} {B = B} {B' = B'} Ï Ï' Ïˆ Î¶ = uncert Ï âˆ¨ (uncert Ïˆ âˆ¨ uncert Î¶) , AR Î» a â†’
      (b , p) â† (provider Ï) a ,
      (b' , p') â† (provider Ï') a , 
      (ep , pf) â† ind' {B = B} {B' = B'} Ïˆ Î¶  b (b' , â‰¡ToFib {A = B} {B = B'} b (right' Ï â–  uB) ( transâ‰¡ (symm p) p') ) ,
      return (ep , transâ‰¡ p pf) 
    --   ind' {!Ïˆ!} {!!} {!!} {!!} 
  -- THE UNC of result is A=>B âˆ¨ (B'=>'P âˆ¨ Ker => P)
supindhelper : {B B' : SubPtd (ð• j)} {q : j â‰¤ k} {A P : SubEl} â†’
     (A=>B : A =>' (j , B))
    â†’ (A=>B' : A =>' (j , B'))
    â†’ (ED : UNC A=>B âˆ¨ UNC A=>B' â‰¤ k)
    â†’ (B'=>P : (j , B') =>' P)
    â†’ (K=>P : Ker q =>' P)
    â†’ A =>'[ UNC (A=>B) âˆ¨ (UNC (B'=>P) âˆ¨ UNC (K=>P)) ] P
supindhelper a=>b a=>b' edge b'=>p ker=>p = SupInd (record
                                                      { A=>B = a=>b ; A=>B' = a=>b' ; edge = edge ; B'=>P = b'=>p ; Ker=>P = ker=>p })
                                                      
syntax supindhelper a=>b a=>b' edge b'=>p ker=>p =
  ROUNDTRIP a=>b JUMPBACK a=>b' âˆ¶  b'=>p MOVECHILDREN edge , ker=>p
