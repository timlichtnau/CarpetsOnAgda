{-# OPTIONS --cubical --without-K #-}
open import CarpetCubical3 
open import CubicalBasics.PointedTypesCubical
open import Relation.Binary.Bundles 
open import Agda.Builtin.Sigma
open import Data.Product
open import CubicalBasics.PropositionReasoning
open import Level
--open import Relation.Binary.PropositionalEquality hiding (trans)
-- open import Relation.Binary.Core
open import Function.Base using (_âˆ˜_)
open import Relation.Binary.Definitions
open import Relation.Binary.Structures using (IsPartialOrder)

open import SemiLattices
open import CubicalBasics.cubical-prelude hiding (_âˆ¨_ ; _âˆ§_)
open import CubicalBasics.cubicalEqualityReasoning
open import HomoAlgStd

open import Grids hiding (_â‰¤_)
open import Data.Nat.Base hiding (_! ; _â‰¤_ ; _âŠ”_)
import UnivalentCarpet2
-- open import CarpetAufsatzExamples2
import SmartImplication
open import Data.Nat.Properties using (nâ‰¤1+n ; â‰¤-refl)
{--
There are two notions in this chapter:
 0 . A â‡” B is saying that B is equal to the pushforward of A along |A|of cocartesian morphism : 
 1. A â‡’ B are


--}

module QuasiIsos {o e} (C : Carpet {o} {â„“} {e})  where

  open UnivalentCarpet2 C
  open Monad truncMonad
 
  private variable
    i j k : Carrier

  0toB0 : (p : k â‰¤ j) â†’ ðŸŽ j =>' ðŸŽ k
  0toB0 {j = j} p = _ , START (AR (Î» x â†’ return (((pts _) , refl) , deeper (sup reflexivity reflexivity) (transâ‰¡ (reflâ‰¡' (projâ‚‚ x)) (symm (bwd (toElâ‰¡ (psv (Ï• p))) reflâ‰¡))) )))
  private    
    0&0 : ðŸŽ j =>' ðŸŽ k --NEEDED?
    0&0 {j = j} {k = k} =  0toF0 uB âˆ· 0toB0 uB' 
--  
{--
A â‡’[ l ] B tells you A =>' B and that one of the equivalent things holds
0. im (A Ã—â‚— FB â†’ FB) âŠ‚ B.  
1. the embedding A Ã—â‚— B â†’ A Ã—â‚— FB is surjective, i.e. an equivalence.
3. A => FB factors through A => B => FB





the map Ï is cocartesian (Sure?): Given a diagram

         B'
         
   __    ^
     |   | âˆƒ! 
  //     |
 //  Ï
A   â‡’    B

_____________________
     l
i ------> j
Means that there exists a unique morphism B -> B over the identity of j (i.e. an inclusion). For the definition of the index category see overleaf.

--}
  _â‡’_ : SubEl â†’ SubEl â†’ Set (lsuc lzero Level.âŠ” o Level.âŠ” e)
  A â‡’ B = Î£[ Ï âˆˆ A =>' B ] (
    âˆ€ b â†’ F B ~ b ~ UNC Ï ~> A 
   â†’ asType (b âˆˆâˆˆ sub B))

{--  _âˆ£_>_ : {A B : SubEl} â†’ (Ï : A â‡’ B) â†’ âˆ€ b â†’ Î£-syntax ã€ sub A ã€‘
                                                (Î» y â†’
                                                   (daIn (F B) , projâ‚ b) â‰¡[ UNC (projâ‚ Ï) ] (daIn A , projâ‚ y)) â†’ asType (b âˆˆâˆˆ sub B)--}
--  syntax Ï âˆ£ b > x = Ï b (return x) -- where open Monad truncMonad
  _â‡’[_]_ : SubEl â†’ Carrier â†’ SubEl â†’ Set (lsuc lzero Level.âŠ” o Level.âŠ” e)

  A â‡’[ l ] B = Î£[ Ï âˆˆ A â‡’ B ] (l â‰¡ UNC (projâ‚ Ï))

    
  intâŠ‚ : {A B : SubPtd (ð• j)} â†’ A âŠ‚ B â†’ (j , A) â‡’ (j , B)
  intâŠ‚ {B = B} p = introâŠ‚ p , Î» b aq â†’
    take
     (a , q) â† aq ,
    subst TâŸ¨ B âŸ© (  sym (reflex _) âˆ™ doesntMatter _ âˆ™  isEmb (eq (symm q)) âˆ™ doesntMatter _ âˆ™ (reflex _) ) (p & a)
    to prove âŸ¨ B âŸ© (projâ‚ b) -- (a , q) â†’ 
  0â‡’ker : (p : k â‰¤ j) â†’ ðŸŽ j â‡’[ j ] Ker p
  0â‡’ker {j = j} p =  foo , refl where -- left' (back (0toB0 p âˆ· 0s))
    open Reasoning

    0s = (0=>'Sth {A = Ker p})
    ut = UNCTrans ( 0toB0 p ) 0s  â–  sup reflexivity p
    foo : ðŸŽ j â‡’ Ker p
    foo = IncUncert' ( 0toB0 p âˆ· 0=>'Sth) ut , Î» (b , pff) â†’
     ( take (px , x) ,          
         (
        ( âŸ¦ Ï• p âŸ§ b
            â‰¡âŸ¨ doesntMatter _ âŸ© --sym (transit _ _ p b) 
          âŸ¦ Ï• (left x)  âŸ§ b 
            â‰¡âŸ¨ (isEmb ( (eq x))) âŸ©
            (âŸ¦ Ï• (right x) âŸ§ (projâ‚ px))
            â‰¡âŸ¨ cong  âŸ¦ Ï• (right x)  âŸ§ (projâ‚‚ px)  âŸ©
          âŸ¦ Ï• (right x) âŸ§ (pt (ð• j) )
            â‰¡âŸ¨ psv (Ï• _) âŸ©
          pt (ð• j) âˆŽ) )
                 to prove
         ( ( b , *) âˆˆâˆˆ ker (Ï• p) ) )

  record _â†—[_]_ (A : SubEl)  (j : Carrier) (B : SubEl) : Set (e âŠ” o âŠ” lsuc lzero) where
    constructor _Â§$_Â§$_
    field
      Aâ‡’B : A â‡’ B
      B=>'A : daIn B â‰¤ daIn A -- F B =>[ UNC (projâ‚ ( Aâ‡’B)) ] F A
      lenProof : (UNC (projâ‚ Aâ‡’B)) â‰¤ j

  0â†—ker : (p : k â‰¤ j) (ed : j â‰¤ i) â†’ ðŸŽ j â†—[ i ] Ker p
  0â†—ker p ed = (projâ‚ (0â‡’ker p)) Â§$ p Â§$ ed --((introâŠ† (p , Î» (x , _) â†’ *)) , re)
  0â†—ker' : (p : k â‰¤ j) â†’ ðŸŽ j â†—[ j ] Ker p
  0â†—ker' p = 0â†—ker p reflexivity

  -- There are two ways to concat â‡’-paths : the first is used whenever the first path has smaller uncertainty as the second, the application would be everything which was done by âˆ· before.
  intâ†” : {A B : SubPtd (ð• j)} â†’ (ed : j â‰¤ k) â†’  A â†” B â†’ (j , A) â†—[ k ] (j , B)
  intâ†” ed p = intâŠ‚ (projâ‚ p) Â§$  re Â§$ ed -- IncUncert' refl=>' reflexivity , reflexivity  Â§$ ed
  trans'â‡’ : {A B C : SubEl} â†’ ((A=>B , _) : A â‡’ B) â†’ ((B=>C , _) : B â‡’ C) â†’ UNC A=>B â‰¤ UNC B=>C â†’ A â‡’ C
  trans'â‡’  {C = C} (A=>B , a-b) (B=>C , b-c) pf = IncUncert' (A=>B âˆ· B=>C) (UNCTrans A=>B B=>C â–   pf âˆ¨R ) , (Î» c â†’
    take (a , c=a) ,
    desquash (b , a=b) â† provider (back A=>B) a ,
    return (b-c c (return (b , (Râˆ¨ pf) â…‹ transâ‰¡ c=a a=b)))
    to prove (c âˆˆâˆˆ (sub C))) 
   -- Otherwise you use the second one, thE Uncertainty have to be as follows: Bâ‡’A â‰¤ Aâ‡’B â‰¤ A'â‡’A
  infixl 5 _âœ¸_
  _âœ¸_ : {A' A B : SubEl} {l : Carrier} â†’ (Î³ : A' â‡’[ l ] A) â†’ A â†—[ l  ]  B â†’ A' â‡’[ l ] B -- (B=>'A , BAâ‰¤AB)
  _âœ¸_ {A' = A'} {A = A}  {B = B} {l = l }((A'=>'A , a'-a) , lenProof) ((A=>'B ,  a-b) Â§$ bâ‰¤a Â§$ ABâ‰¤A'A) = (IncUncert' (A'=>'A âˆ· A=>'B) (((UNCTrans A'=>'A A=>'B â–  ( left-map (projâ‚‚ lp) â–  Râˆ¨ ABâ‰¤A'A ))) )  , foo) , refl where
    lp = convertEq lenProof
    BAâ‰¤AB : daIn A â‰¤ UNC A=>'B
    BAâ‰¤AB = left' (back A=>'B)
    B=>'A : F B =>' F A
    B=>'A = FWD bâ‰¤a âˆ· Sth=>'Full 
    foo : âˆ€ b â†’ 
            F B ~ b ~ l ~> A' â†’
            TâŸ¨ sub B âŸ© (projâ‚ b)
    foo b = take
      (a' , b=a') , desquash
      (a , b=a) â† provider (back (B=>'A)) b ,
      return ( a-b b (return (((projâ‚ a) , (a'-a (projâ‚ a , *) (return (a' , ( (BAâ‰¤AB  â–  ABâ‰¤A'A) âˆ¨R â–  projâ‚ lp ) â…‹ transâ‰¡ (symm b=a) b=a')))) , deeper BAâ‰¤AB b=a)) )
      to prove (b âˆˆâˆˆ sub B)   

  DecUnc : {A B : SubPtd (ð• j)} {p : j â‰¤ k} â†’ Mono p â†’ (j , A) =>'[ k ] (j , B) â†’  A âŠ‚ B
  DecUnc {p = p} mo me = toâŠ‚ ((
    ROUNDTRIP
      _ , me  âˆ¶
      refl=>'
    MOVECHILDREN  re  
      < introâŠ‚ mo âˆ· 0=>'Sth >))
    (Râˆ¨ re) 
      
  module _ {B'' : SubPtd (ð• j)}  ((0kâ‡’B'' , p') : ðŸŽ k â‡’[ k ] (j , B'')) where
    private
      p = convertEq p'
      q : j â‰¤ k
      q = right' (back (projâ‚ 0kâ‡’B'')) â–   projâ‚‚ p
    supIndOverTheRoof : {A P : SubEl}  {B : SubPtd (ð• j)}  â†’
        (A=>B : A =>' (j , B))
      â†’ (A=>0k : A =>'[ k ] ðŸŽ k)  
      â†’ UNC A=>B  â‰¤ k

      â†’ (B''=>P : (j , B'') =>' P)
      â†’ A =>'[ UNC A=>B âˆ¨ UNC B''=>P ] P
    --supporter INDUCTION over the roof has uncertainty A=>B âˆ¨ B''=>P.
    supIndOverTheRoof A=>B A=>0k edge  B''=>P = 
     IncUncert'' bar (right-map (atLeast (back B''=>P) âˆ¨R)) where
      bar : _ =>'[ UNC A=>B âˆ¨ (UNC (0&0) âˆ¨ UNC ( B''=>P)) ] _
      bar = 
        ROUNDTRIP
          A=>B
        JUMPBACK
          _ , A=>0k âˆ· 0toB0 q âˆ¶ 0&0 âˆ· 0=>'Sth 
        MOVECHILDREN sup (edge) ( (UNCTrans (k , A=>0k) (0toB0 q) â–  Râˆ¨ re ) ),
        (introâŠ‚ foo âˆ· B''=>P) where

        foo : ker (Ï• q) âŠ‚ B''
        foo = âŠ‚: Î» x â†’ (projâ‚‚ (0kâ‡’B'')) (projâ‚ x , * ) (return
          (pt âŸª 0Sub {X = ð• k}  âŸ« , deeper (projâ‚ p)
            (symm (deeper (reflexivity âˆ¨R)
              (transâ‰¡ (symm (bwd refl (reflâ‰¡' (sym (projâ‚‚ x))) ))
                      (deeper q (reflâ‰¡' refl)))))) )
        
    syntax supIndOverTheRoof 0kâ‡’B'' A=>B A=>0k edge B''=>P =
      ROUNDTRIP
        A=>B
      JUMPBACK
        A=>0k âˆ¶
        0kâ‡’B'' âˆ¶
        B''=>P , edge
    
    gobackwards :  {P : SubEl} {A : SubPtd (ð• j)}      
      â†’ (A=>0k : (j , A) =>'[ k ] ðŸŽ k)
      â†’ (B''=>P : (j , B'') =>' P)
      â†’ (j , A) =>'[ UNC (B''=>P) ] P
    gobackwards {P = P} {A = A} (A=>0k) = bar where
      foo : (B''=>P : (j , B'') =>' P)  â†’ (j , A) =>'[ UNC (B''=>P) ] P
      foo B''=>P = IncUncert'' (
        supIndOverTheRoof
          refl=>'      
          A=>0k 
          q
          B''=>P )
        (left' (back B''=>P) âˆ¨R) -- UNC of backwards is B''=>P.
      bar : (B''=>P : (j , B'') =>' P)  â†’ (j , A) =>'[ UNC (B''=>P) ] P
      bar (j , SmartImplication.START pâ‚ ) = NOTHING (back (_ , foo (j , START pâ‚ )))
      bar (j , SmartImplication.END pâ‚ ) = END (provider' (back (_ , foo (j , END pâ‚))) )
      bar (j , SmartImplication.EQUAL pâ‚ ) = EQUAL (provider' (back (_ , foo (j , EQUAL pâ‚))) )
      bar (j , SmartImplication.NOTHING x ) = NOTHING (back (_ , foo (j , NOTHING x)))
    syntax gobackwards 0kâ‡’B'' A=>0k B''=>P  =
      BACKWARDS
        A=>0k âˆ¶
        0kâ‡’B'' âˆ¶
        B''=>P 

   -- first : {A B : SubEl}  {j : Carrier} â†’ A â†—[ j ] B â†’ A â‡’ B
   -- first (x Â§$ y Â§$ z) = x



